"use strict";

/**
 * Gets the resulting install command given the provided arguments
 * @async
 * @param {string[]} extraArgs - arguments to be passed to the CLI
 * @param {boolean} noDryRun - whether to actually run the command or not
 * @returns {Promise<string>} - a Promise which resolves to the resulting install command
 */
var getCliInstallCommand = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(extraArgs) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve, reject) {
              // Always do dry run, so the command is the last
              // non-whitespace line written to stdout
              var cli = spawnCli([].concat(_toConsumableArray(extraArgs), ["--dry-run"]));
              var fullstdout = [];
              cli.stdout.on("data", function (data) {
                // not guaranteed to be line-by-line in fact these can be Buffers
                fullstdout.push(data);
              });
              cli.on("close", function () {
                // The command will be the last non-whitespace line written to
                // stdout by the cli during a dry run

                var lines = fullstdout.join("").split(/\r?\n/g).filter(function (l) {
                  return !!l.trim();
                });

                resolve(lines[lines.length - 1]);
              });
              // Make sure to call reject() on error so that the Promise
              // doesn't hang forever
              cli.on("error", function (err) {
                return reject(err);
              });
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function getCliInstallCommand(_x2) {
    return _ref.apply(this, arguments);
  };
}();

var _child_process = require("child_process");

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _tape = require("tape");

var _tape2 = _interopRequireDefault(_tape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Spawns the CLI with the provided arguments
 * @param {string[]} extraArgs - arguments to be passed to the CLI
 * @returns {ChildProcess} - an EventEmitter that represents the spawned child process
 */
function spawnCli(extraArgs) {
  var cwd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "sandbox";

  var fullCwd = _path2.default.join(__dirname, "..", "fixtures", cwd);

  // Clean up sandbox before and after every run
  if (cwd === "sandbox") {
    _fs2.default.copyFileSync(_path2.default.join(fullCwd, "package-clean.json"), _path2.default.join(fullCwd, "package.json"));
  }

  var cli = (0, _child_process.spawn)("node", ["--require", "babel-register", _path2.default.join(__dirname, "cli.js")].concat(_toConsumableArray(extraArgs)), { cwd: fullCwd });

  // Clean up sandbox before and after every run
  cli.on("exit", function () {
    if (cwd === "sandbox") {
      _fs2.default.copyFileSync(_path2.default.join(fullCwd, "package-clean.json"), _path2.default.join(fullCwd, "package.json"));
    }
  });

  return cli;
}

(0, _tape2.default)("errors when more than one package is provided", function (t) {
  var cli = spawnCli(["eslint-config-airbnb", "angular"]);
  cli.on("exit", function (code) {
    // We should be able to do t.equal(code, 1), but earlier Node versions
    // handle uncaught exceptions differently so we can't (0.10 returns 8,
    // 0.12 returns 9).
    t.notEqual(code, 0, "errored, exit code was " + code + ".");
    t.end();
  });
});

(0, _tape2.default)("errors when no arguments are provided", function (t) {
  var cli = spawnCli([]);
  cli.on("exit", function (code) {
    t.notEqual(code, 0, "errored, exit code was " + code);
    t.end();
  });
});

(0, _tape2.default)("errors when the package name argument is formatted incorrectly", function (t) {
  var cli = spawnCli(["heyhe#@&*()"]);
  cli.on("exit", function (code) {
    t.notEqual(code, 0, "errored, exit code was " + code);
    t.end();
  });
});

(0, _tape2.default)("only installs peerDependencies when `--only-peers` is specified", function (t) {
  getCliInstallCommand(["eslint-config-airbnb", "--only-peers"]).then(function (command) {
    var cmd = command.toString();
    t.equal(/ eslint-config-airbnb /.test(cmd), false);
    t.end();
  }, t.fail);
});

(0, _tape2.default)("adds explicit `--save-dev` flag when using `-D, -d, --dev` with NPM", function (t) {
  var flags = ["-D", "-d", "--dev"];
  Promise.all(flags.map(function (flag) {
    return getCliInstallCommand(["eslint-config-airbnb", flag]);
  })).then(function (commands) {
    commands.forEach(function (cmd, i) {
      return t.equal(/ --save-dev /.test(cmd), true, "flag: `" + flags[i] + "`");
    });
    t.end();
  }).catch(t.fail);
});

(0, _tape2.default)("places `global` as first arg following `yarn` when using yarn and `--global` is specified", function (t) {
  getCliInstallCommand(["eslint-config-airbnb", "--global", "-Y"]).then(function (command) {
    var cmd = command.toString();
    t.equal(/^yarn global/.test(cmd), true);
    t.end();
  }, t.fail);
});

(0, _tape2.default)("adds explicit `--global` flag when using `--global` with NPM", function (t) {
  getCliInstallCommand(["eslint-config-airbnb", "--global"]).then(function (command) {
    var cmd = command.toString();
    t.equal(/\bnpm\s--global\b/.test(cmd), true);
    t.end();
  }, t.fail);
});

(0, _tape2.default)("does not add `--save` when using `--global` with NPM", function (t) {
  getCliInstallCommand(["eslint-config-airbnb", "--global"]).then(function (command) {
    var cmd = command.toString();
    t.equal(/\s--save\b/.test(cmd), false);
    t.end();
  }, t.fail);
});

(0, _tape2.default)("adds an explicit `--no-save` when using `--silent` with NPM", function (t) {
  getCliInstallCommand(["eslint-config-airbnb", "--silent"]).then(function (command) {
    var cmd = command.toString();
    t.equal(/\s--no-save\b/.test(cmd), true);
    t.end();
  }, t.fail);
});

(0, _tape2.default)("installs with pnpm successfully", function (t) {
  var cli = spawnCli(["eslint-config-airbnb", "--pnpm"], "pnpm");
  cli.on("data", function (data) {
    t.comment(data);
  });
  cli.on("exit", function (code) {
    if (code !== 0) {
      t.fail("CLI exited with error code " + code);
    }
    var hasPnpmLockYaml = _fs2.default.existsSync(_path2.default.resolve(__dirname, "..", "fixtures", "pnpm", "pnpm-lock.yaml"));
    t.equal(hasPnpmLockYaml, true);
    t.end();
  });
});

// See https://github.com/nathanhleung/install-peerdeps/issues/33
// test("installs packages correctly even if package name ends with '-0'", t => {
//   const cli = spawnCli(["enzyme-adapter-react-16@1.1.1"]);
//   cli.on("exit", code => {
//     t.equal(code, 0, `errored, exit code was ${code}.`);
//     t.end();
//   });
// });

// Work on this test later
/*
test("doesn't replace existing installed peer dependencies", t => {
  const fullCwd = path.join(__dirname, "..", "fixtures", "replace");

  const npm = spawn("npm", ["install", "data-forge"], {
    cwd: fullCwd
  });

  function onCliExit(code, forgeVersion) {
    if (code !== 0) {
      t.fail(`errored, cli exit code was ${code}.`);
    }

    fs.readFile(`${fullCwd}/package.json`, "utf8", (err, data) => {
      if (err) {
        t.fail(`errored, couldn't open package.json`);
      }

      const pkg = JSON.parse(data);
      const newForgeVersion = pkg.dependencies["data-forge"];

      t.equal(
        newForgeVersion,
        forgeVersion,
        `error, replaced old peer. ${newForgeVersion} replaced ${forgeVersion}`
      );
    });
  }

  npm.on("exit", code => {
    if (code !== 0) {
      t.fail(`errored, npm install exit code was ${code}.`);
    }

    fs.readFile(`${fullCwd}/package.json`, "utf8", (err, data) => {
      if (err) {
        t.fail(`errored, couldn't open package.json`);
      }

      const pkg = JSON.parse(data);
      const forgeVersion = pkg.dependencies["data-forge"];

      const cli = spawnCli(["data-forge-indicators"], "replace");
      cli.on("exit", cliExitCode => onCliExit(cliExitCode, forgeVersion));
    });
  });
});
*/

// @todo - tests for the actual install process
// see https://github.com/sindresorhus/has-yarn/blob/master/test.js for details
// Perhaps abstract the functionality of getting the package name
// into its own function, and test that

// Also see commander tests
// https://github.com/tj/commander.js/blob/master/test/test.arguments.js